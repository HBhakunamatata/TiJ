# Type Information

- Runtime type information (RTTI) allows you to discover and 
    use type information when a program is running.

- This chapter looks at the ways that Java allows you to discover 
  information about objects and classes at run time.
- It frees you from the constraint of doing type-oriented things 
  only at compile time, and can enable some very powerful programs. 
- The need for RTTI uncovers a plethora of 00 design issues, 
  and raises fundamental questions about how to structure your programs. 
- Two Forms
    - "traditional" RTTI : you have all the types available at compile time
    - Reflection mechanism : allows you to discover and use class information at run time.

## The need for RTTI

- The goal for OOP is to manipulate reference to the based type.

## The Class object

- Java perform RTTI using the Class object, which is used to create objects
    and contains all information about class, even if you are doing something like _cast_
- Class object is created when you write and compile a new class.
- JVM uses _class loader_ to load .class file and create objects.
- All classes are load dynamically when the program makes the first reference 
    to a __static__ member(constructor) of the class. (_important_)
- Thus, a Java program is partially loaded when necessary.(_dynamic loading_)
- Demo : SweetShop.java

- Anytime you want to use type information at run time, 
  you must first get a reference to the appropriate Class object.
    - without object : static forName(String className) --> Class
    - access object : object.getClass --> Class

### Class literals

- Java provides a second way to create the reference of __Class__ object.
- Class literal is checked at compile time.
- Class literals can work with interfaces, arrays and primitive types.
```
  Class c = String.class; // must ClassName.class
```
- A pic (TODO)
- _Note that creating a reference to a __Class__ object using ".class" 
    will not automatically initialize the __Class__ object._???
- There are three steps in preparing a class for use:
    - (1) _Loading_. which is performed by the class loader. 
         It finds the bytecodes and creates a Class object.
    - (2) _Linking_. The link phase verifies the bytecodes in the class, 
        allocates storage for static fields, and if necessary, 
        resolves all references to other classes made by this class.
    - (3) _Initialization_. If there’s a superclass, initialize that. 
        Execute static initializers and static initialization blocks.
- __Note:__ Initialization is delayed until the first reference to a static method 
        (the constructor is implicitly static) or to a non-constant static field.

- Demo : ClassInitialization.java

### Generic class references

- A Class reference points to a __Class__ object, which contains all methods code 
  and statics for the class and manufactures instances of classes.
- However, we can use generic syntax to constrain the type of _Class_ object.
- We use a _wild_ symbol to loosen the constraints,  
  and use a _? extends Type_ to create a Class reference constrained to 
    a type or any subtype.

- Demo : GenericClassReference.java

- Note: 
    > Class<Number> genericNumberClass = int.class;  
    This doesn’t work, because Integer is inherited from Number,
    but the Integer Class object is not a subclass of the Number Class object.

- When you use the generic syntax for Class objects: newlnstance() 
  will return the exact type of the object, rather than just a basic Object.
- Demo : FilledList.java / ToyTest.java

### New cast syntax(*)

- Demo : ClassCasts.java

## Checking before a cast

- 