# Ch17 I/O

- Creating a good input/output (I/O) system is one of the most difficult task
  for language designer. This is evidenced by the number of different approaches.

## The __File__ class

- The __File__ class represents the path of files. That is:
    - it can be the name of a particular file.
    - it can also be the names of a set of files in a directory.
    
- FileNameFilter : accept()  

A class that tells how to select the File objects for display.
- Demo : FileDir.java
This is an ideal example for rewriting to using an anonymous class.(tightly bound to DirList2)
- Demo : FileDir2.java

### Directory tools

- Demo : Directory.java (mindview)

- good performance in demo

```
class TreeInfo {}
public static TreeInfo
walk(String start, String regex) { // Begin recursion
    return recurseDirs(new File(start), regex);
}
public static TreeInfo
walk(File start, String regex) { // Overloaded
    return recurseDirs(start, regex);
}
public static TreeInfo walk(File start) { // Everything
    return recurseDirs(start, ".*");
}
public static TreeInfo walk(String start) {
    return recurseDirs(new File(start), ".*");
}
static TreeInfo recurseDirs(File startDir, String regex){
    TreeInfo result = new TreeInfo();
    for(File item : startDir.listFiles()) {
        if(item.isDirectory()) {
            result.dirs.add(item);
            result.addAll(recurseDirs(item, regex));
        } 
        // Regular file
        else if(item.getName().matches(regex))
            result.files.add(item);
    }
    return result;
}
```

- The Directory utility is placed in the net.mindview.util package so that it is easily available. Here’s a sample of how you can use it

- Demo : DirectoryDemo.java

- We can take this a step further and create a tool that will walk directories and process the files within them according to a Strategy object

- Demo : ProcessFile.java (mindview)

### Checking for and creating directories

- MakeDirectories.java (Not need to rewrite)

## Input and output

- Programming language I/O libs often use the abstraction of stream, which presents 
  any data resource or an object producing or receiving from data.
- The steam hides the details of what happens to the data inside of the actual I/O device.

- InputStream / Reader    read()
- OutputStream / Writer    write()

### Type of __InputStream__

    - Array of Bytes          ------------    ByteArrayInputStream / byteArrayOutputStream
    - An String object        ------------    StringBufferInputStream / - (new String(byte[]))
    - A file                  ------------    FileInputStream / FileOutputStream
    - A pipe (A followed B)   ------------    PipedInputStream / PipedOutputStream
    - A sequence of other stream  ------------  SequenceInputStream / - (All in one)
    - A network connection    ------------

- Each of these has an associated subclass of InputStream.   
- In addition, the __FilterInputStream / FilterOutputStream__ is also a type of InputStream / OutputStream, to provide a base class for "__decorator__" classes that attach attributes or useful interfaces to input / output streams.

## Adding attributes and useful interfaces

- The reason for the existence of the "filter" classes in the Java I/O library
  is that the abstract "filter" class is the base class for all the decorators.
- A decorator must have the same interface as the object it decorates, but the
     decorator can extend the interface.

    - Number  ---------------  DataInputStream / DataOutputStream
    - Buffered  --------------  BufferedInputStream / BufferedOutputStream
    -                             PrintStream (this is for show)

## __Reader__s & __Writer__s

- When you see the Reader and Writer classes, your first thought that these were meant to replace the InputStream and OutputStream classes. But that’s not the case.

- The connection between them :

    - 1. the InputStream and OutputStream classes still provide valuable functionality in the form of __byte-oriented I/O__.
    - 1. the Reader and Writer classes provide Unicode-compliant, __character-based I/O__.
    
    - 2. There are times when you must use classes from the "byte" hierarchy in combination with classes in the "character" hierarchy. To accomplish this, there are "adapter" classes: InputStreamReader converts an InputStream to a Reader, and OutputStreamWriter converts an OutputStream to a Writer.

- The most important reason for the Reader and Writer hierarchies is for internationalization. (8-bit byte streams ---> 16-bit byte streams)

### Type of readers and writers

- Although BufferedOutputStream is a subclass of FilterOutputStream, 
  BufferedWriter is not a subclass of FilterWriter.
 

