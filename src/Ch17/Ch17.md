# Ch17 I/O

- Creating a good input/output (I/O) system is one of the most difficult task
  for language designer. This is evidenced by the number of different approaches.

## The __File__ class

- The __File__ class represents the path of files. That is:
    - it can be the name of a particular file.
    - it can also be the names of a set of files in a directory.
    
- FileNameFilter : accept()  

A class that tells how to select the File objects for display.
- Demo : FileDir.java
This is an ideal example for rewriting to using an anonymous class.(tightly bound to DirList2)
- Demo : FileDir2.java

### Directory tools

- Demo : Directory.java (mindview)

- good performance in demo

```
class TreeInfo {}
public static TreeInfo
walk(String start, String regex) { // Begin recursion
    return recurseDirs(new File(start), regex);
}
public static TreeInfo
walk(File start, String regex) { // Overloaded
    return recurseDirs(start, regex);
}
public static TreeInfo walk(File start) { // Everything
    return recurseDirs(start, ".*");
}
public static TreeInfo walk(String start) {
    return recurseDirs(new File(start), ".*");
}
static TreeInfo recurseDirs(File startDir, String regex){
    TreeInfo result = new TreeInfo();
    for(File item : startDir.listFiles()) {
        if(item.isDirectory()) {
            result.dirs.add(item);
            result.addAll(recurseDirs(item, regex));
        } 
        // Regular file
        else if(item.getName().matches(regex))
            result.files.add(item);
    }
    return result;
}
```

- The Directory utility is placed in the net.mindview.util package so that it is easily available. Here’s a sample of how you can use it

- Demo : DirectoryDemo.java

- We can take this a step further and create a tool that will walk directories and process the files within them according to a Strategy object

- Demo : ProcessFile.java (mindview)

### Checking for and creating directories

- MakeDirectories.java (Not need to rewrite)

## Input and output

- Programming language I/O libs often use the abstraction of stream, which presents 
  any data resource or an object producing or receiving from data.
- The steam hides the details of what happens to the data inside of the actual I/O device.

- InputStream / Reader    read()
- OutputStream / Writer    write()

### Type of __InputStream__

    - Array of Bytes          ------------    ByteArrayInputStream / byteArrayOutputStream
    - An String object        ------------    StringBufferInputStream / - (new String(byte[]))
    - A file                  ------------    FileInputStream / FileOutputStream
    - A pipe (A followed B)   ------------    PipedInputStream / PipedOutputStream
    - A sequence of other stream  ------------  SequenceInputStream / - (All in one)
    - A network connection    ------------

- Each of these has an associated subclass of InputStream.   
- In addition, the __FilterInputStream / FilterOutputStream__ is also a type of InputStream / OutputStream, to provide a base class for "__decorator__" classes that attach attributes or useful interfaces to input / output streams.

## Adding attributes and useful interfaces

- The reason for the existence of the "filter" classes in the Java I/O library
  is that the abstract "filter" class is the base class for all the decorators.
- A decorator must have the same interface as the object it decorates, but the
     decorator can extend the interface.

    - Number  ---------------  DataInputStream / DataOutputStream
    - Buffered  --------------  BufferedInputStream / BufferedOutputStream
    -                             PrintStream (this is for show)

## __Reader__s & __Writer__s

- When you see the Reader and Writer classes, your first thought that these were meant to replace the InputStream and OutputStream classes. But that’s not the case.

- The connection between them :

    - 1. the InputStream and OutputStream classes still provide valuable functionality in the form of __byte-oriented I/O__.
    - 1. the Reader and Writer classes provide Unicode-compliant, __character-based I/O__.
    
    - 2. There are times when you must use classes from the "byte" hierarchy in combination with classes in the "character" hierarchy. To accomplish this, there are "adapter" classes: InputStreamReader converts an InputStream to a Reader, and OutputStreamWriter converts an OutputStream to a Writer.

- The most important reason for the Reader and Writer hierarchies is for internationalization. (8-bit byte streams ---> 16-bit byte streams)

### Type of readers and writers

- Although BufferedOutputStream is a subclass of FilterOutputStream, 
  BufferedWriter is not a subclass of FilterWriter.
 



## Typical uses of I/O Streams

### Input 

- (1) Buffered input file (BufferReader readLine())
- Demo : BufferedInputFile.java

- (2) Input from memory (StringReader read())
- Demo : MemoryInput.java
- __Note__ : StringReader just reads a _int_ into memory, 
                you need to cast to _char_ when using.

- (3) Formatted memory input (DataInputStream readByte())
- To read "formatted" data, you use a DataInputStream, which is a byte-oriented I/O class (rather than char-oriented). Thus you must use all InputStream classes rather than Reader classes. Of course, you can read anything (such as a file) as bytes using InputStream classes, but here a String is used.
- Demo : FormattedMemoryInput.java / TestEOF.java

### Output (PrintWriter BufferedWriter FIleWriter)

- (1) Basic file input
- Demo : BasicFileOutput.java

### Storing and recovering data (DataInputStream BufferedInputStream FileInputStream)

- PrintWriter formats data so that it is readable by human.
- However, when you just store and recover data from disk,
 you need to DataInputStream and DataOutputStream.
 
- Demo : StoringAndRecoveringData.java

- Note : you can store and recover data using writeXXX() and readXXX(),
    but if anyone uses another methods, you need mark the exact placement of the data item in the stream (object serialization and XML ...).
    
### Random-access files ()

- RandomAccessFile = DataInputStream + DataOutputStream
- When using RandomAccessFile, you must know the layout of file 
  so that you can manipulate primitive and String with seek() properly.
- Demo : UsingRandomAccessFile.java
